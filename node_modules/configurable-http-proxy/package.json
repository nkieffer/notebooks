{
  "version": "1.3.1",
  "name": "configurable-http-proxy",
  "description": "A configurable-on-the-fly HTTP Proxy",
  "author": {
    "name": "Jupyter Developers"
  },
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "https://github.com/jupyterhub/configurable-http-proxy.git"
  },
  "dependencies": {
    "commander": "~2.9",
    "http-proxy": "~1.13.2",
    "lynx": "^0.2.0",
    "strftime": "~0.9",
    "winston": "~2.2"
  },
  "devDependencies": {
    "jasmine": "^2.4.1",
    "jshint": "^2.9.2",
    "nyc": "^6.4.0",
    "request": "~2",
    "ws": "^1.1"
  },
  "main": "index.js",
  "files": [
    "index.js",
    "lib/configproxy.js",
    "lib/trie.js",
    "lib/error/*.html",
    "bin/configurable-http-proxy"
  ],
  "bin": {
    "configurable-http-proxy": "bin/configurable-http-proxy"
  },
  "scripts": {
    "jshint": "jshint bin/ lib/ test/",
    "test": "nyc jasmine JASMINE_CONFIG_PATH=test/jasmine.json",
    "coverage-html": "nyc report --reporter=html",
    "codecov": "nyc report --reporter=lcov && codecov"
  },
  "readme": "# configurable-http-proxy\n\nA simple wrapper around [node-http-proxy][] that adds a REST API for updating the routing table.\n\nThe proxy is developed as a part of the [Jupyter Hub][] multi-user server.\n\n[node-http-proxy]: https://github.com/nodejitsu/node-http-proxy\n[Jupyter Hub]: https://github.com/jupyterhub/jupyterhub\n\n\n## Install\n\nTo install `configurable-http-proxy`:\n\n    npm install -g configurable-http-proxy\n\nTo install from the repo:\n    \n    git clone https://github.com/jupyterhub/configurable-http-proxy.git\n    cd configurable-http-proxy\n    # Use -g for global install\n    npm install [-g]\n\n## Using configurable-http-proxy\n\n\nthe configurable proxy runs two HTTP(S) servers:\n\n1. The public-facing interface to your application (controlled by `--ip`, `--port`, etc.).\n   This listens on **all interfaces** by default.\n2. The inward-facing REST API (`--api-ip`, `--api-port`). This listens on localhost by default.\n   The REST API uses token authorization, set by the `CONFIGPROXY_AUTH_TOKEN` environment variable.\n\nWhen you start the proxy, you can set a default target to be used when no match is found\nin the proxy table:\n\n    $ configurable-http-proxy --default-target=http://localhost:8888\n\n### Options\n\n```\n  Usage: configurable-http-proxy [options]\n\n  Options:\n\n    -h, --help                       output usage information\n    -V, --version                    output the version number\n    --ip <ip-address>                Public-facing IP of the proxy\n    --port <n> (defaults to 8000)    Public-facing port of the proxy\n    --ssl-key <keyfile>              SSL key to use, if any\n    --ssl-cert <certfile>            SSL certificate to use, if any\n    --ssl-ca <ca-file>               SSL certificate authority, if any\n    --ssl-request-cert               Request SSL certs to authenticate clients\n    --ssl-reject-unauthorized        Reject unauthorized SSL connections (only meaningful if --ssl-request-cert is given)\n    --ssl-protocol <ssl-protocol>    Set specific HTTPS protocol, e.g. TLSv1_2, TLSv1, etc.\n    --ssl-ciphers <ciphers>          `:`-separated ssl cipher list. Default excludes RC4\n    --ssl-allow-rc4                  Allow RC4 cipher for SSL (disabled by default)\n    --ssl-dhparam <dhparam-file>     SSL Diffie-Helman Parameters pem file, if any\n    --api-ip <ip>                    Inward-facing IP for API requests\n    --api-port <n>                   Inward-facing port for API requests (defaults to --port=value+1)\n    --api-ssl-key <keyfile>          SSL key to use, if any, for API requests\n    --api-ssl-cert <certfile>        SSL certificate to use, if any, for API requests\n    --api-ssl-ca <ca-file>           SSL certificate authority, if any, for API requests\n    --api-ssl-request-cert           Request SSL certs to authenticate clients for API requests\n    --api-ssl-reject-unauthorized    Reject unauthorized SSL connections (only meaningful if --api-ssl-request-cert is given)\n    --default-target <host>          Default proxy target (proto://host[:port])\n    --error-target <host>            Alternate server for handling proxy errors (proto://host[:port])\n    --error-path <path>              Alternate server for handling proxy errors (proto://host[:port])\n    --redirect-port <redirect-port>  Redirect HTTP requests on this port to the server on HTTPS\n    --pid-file <pid-file>            Write our PID to a file\n    --no-x-forward                   Don't add 'X-forward-' headers to proxied requests\n    --no-prepend-path                Avoid prepending target paths to proxied requests\n    --no-include-prefix              Don't include the routing prefix in proxied requests\n    --insecure                       Disable SSL cert verification\n    --host-routing                   Use host routing (host as first level of path)\n    --statsd-host <host>             Host to send statsd statistics to\n    --statsd-port <port>             Port to send statsd statistics to\n    --statsd-prefix <prefix>         Prefix to use for statsd statistics\n    --log-level <loglevel>           Log level (debug, info, warn, error)\n```\n\n## REST API\n\nThe REST API is authenticated via a token in the `Authorization` header.\nThe API is served under the `/api/routes` base URL.\nFor example:\n\n    $> curl -H \"Authorization: token $CONFIGPROXY_AUTH_TOKEN\" http://localhost:8001/api/routes\n\n\n### Getting the current routing table\n\n    GET /api/routes[?inactive_since=ISO8601-timestamp]\n\nReturns a JSON dictionary of the current routing table. This *excludes* the default route.\nIf the `inactive_since` URL parameter is given as an [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) timestamp,\nonly routes whose `last_activity` is earlier than the timestamp will be returned.\n\n#### Response\n\n    status: 200 OK\n\n```json\n{\n  \"/user/foo\": {\n    \"target\": \"http://localhost:8002\",\n    \"last_activity\": \"2014-09-08T19:43:08.321Z\"\n  },\n  \"/user/bar\": {\n    \"target\": \"http://localhost:8003\",\n    \"last_activity\": \"2014-09-08T19:40:17.819Z\"\n  }\n}\n```\n\nThe `last_activity` timestamp is updated whenever the proxy passes any data to or from\nthe proxy target.\n\n\n### Adding new routes\n\nPOST requests create new routes. The body of the request should be a JSON dictionary\nwith at least one key: `target`, the host to be proxied.\n\n    POST /api/routes/[:path]\n\n#### Input\n\n<dl>\n    <dt>target</dt>\n    <dd>The host URL</dd>\n</dl>\n\n#### Response\n\n    status: 201 Created\n\nAny request to `/path/prefix` on the proxy's public interface will be proxied to `target`.\n\n### Deleting routes\n\n    DELETE /api/routes/[:path]\n\n#### Response\n\n    status: 204 No Content\n\n## Custom error pages\n\nCHP 0.5 adds two ways to provide custom error pages when the proxy encounters an error,\nand has no proxy target to handle a request. There are two typical errors that CHP can hit:\n\n- 404: a client has requested a URL for which there is no routing target.\n  This is impossible if a default target has been specified.\n- 503: a route exists, but the upstream server isn't responding.\n  This is more common, and can be due to any number of reasons,\n  including the target service having died or not finished starting.\n\n### error-path\n\nIf you specify `--error-path /usr/share/chp-errors`,\nthen when a proxy error occurs, CHP will look in `/usr/share/chp-errors/CODE.html` for an html page to serve,\ne.g. `404.html` or `503.html`.\nIf no file exists for the error code,  `error.html` file will be used.\nIf you use this scheme, make sure you have at least `error.html`.\n\n### error-target\n\nIf you specify `--error-target http://localhost:1234`,\nthen when the proxy encounters an error, it will make a GET request to this server, with URL `/CODE`,\nand the URL of the failing request escaped in a URL parameter, e.g.:\n\n    GET /404?url=%2Fescaped%2Fpath\n\n\n## Host-based routing\n\nIf `--host-routing` is given, the proxy will pick a target based on the host of the incoming request,\ninstead of the URL prefix.\nThe API when using host-based routes is the same as if the hostname were the first part of the URL path, e.g.\n\n```python\n{\n  \"/example.com\": \"https://localhost:1234\",\n  \"/otherdomain.biz\": \"http://10.0.1.4:5555\",\n}\n```\n\netc.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jupyterhub/configurable-http-proxy/issues"
  },
  "_id": "configurable-http-proxy@1.3.1",
  "_from": "configurable-http-proxy@"
}
